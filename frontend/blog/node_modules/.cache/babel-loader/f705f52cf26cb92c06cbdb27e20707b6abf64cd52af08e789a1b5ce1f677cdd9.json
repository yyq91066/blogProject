{"ast":null,"code":"/**\n* @vue/reactivity v3.5.25\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { extend, hasChanged, isArray, isIntegerKey, isSymbol, isMap, hasOwn, makeMap, isObject, capitalize, toRawType, def, isFunction, EMPTY_OBJ, isSet, isPlainObject, remove, NOOP } from '@vue/shared';\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal track `on` calls, allow `on` call multiple times\n     */\n    this._on = 0;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  pause() {\n    if (this._active) {\n      this._isPaused = true;\n      let i, l;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].pause();\n        }\n      }\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].pause();\n      }\n    }\n  }\n  /**\n   * Resumes the effect scope, including all child scopes and effects.\n   */\n  resume() {\n    if (this._active) {\n      if (this._isPaused) {\n        this._isPaused = false;\n        let i, l;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].resume();\n          }\n        }\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].resume();\n        }\n      }\n    }\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    if (++this._on === 1) {\n      this.prevScope = activeEffectScope;\n      activeEffectScope = this;\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    if (this._on > 0 && --this._on === 0) {\n      activeEffectScope = this.prevScope;\n      this.prevScope = void 0;\n    }\n  }\n  stop(fromParent) {\n    if (this._active) {\n      this._active = false;\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      this.effects.length = 0;\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      this.cleanups.length = 0;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n        this.scopes.length = 0;\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn, failSilently = false) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);\n  }\n}\nlet activeSub;\nconst EffectFlags = {\n  \"ACTIVE\": 1,\n  \"1\": \"ACTIVE\",\n  \"RUNNING\": 2,\n  \"2\": \"RUNNING\",\n  \"TRACKING\": 4,\n  \"4\": \"TRACKING\",\n  \"NOTIFIED\": 8,\n  \"8\": \"NOTIFIED\",\n  \"DIRTY\": 16,\n  \"16\": \"DIRTY\",\n  \"ALLOW_RECURSE\": 32,\n  \"32\": \"ALLOW_RECURSE\",\n  \"PAUSED\": 64,\n  \"64\": \"PAUSED\",\n  \"EVALUATED\": 128,\n  \"128\": \"EVALUATED\"\n};\nconst pausedQueueEffects = /* @__PURE__ */new WeakSet();\nclass ReactiveEffect {\n  constructor(fn) {\n    this.fn = fn;\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 1 | 4;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    /**\n     * @internal\n     */\n    this.cleanup = void 0;\n    this.scheduler = void 0;\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n  pause() {\n    this.flags |= 64;\n  }\n  resume() {\n    if (this.flags & 64) {\n      this.flags &= -65;\n      if (pausedQueueEffects.has(this)) {\n        pausedQueueEffects.delete(this);\n        this.trigger();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    if (this.flags & 2 && !(this.flags & 32)) {\n      return;\n    }\n    if (!(this.flags & 8)) {\n      batch(this);\n    }\n  }\n  run() {\n    if (!(this.flags & 1)) {\n      return this.fn();\n    }\n    this.flags |= 2;\n    cleanupEffect(this);\n    prepareDeps(this);\n    const prevEffect = activeSub;\n    const prevShouldTrack = shouldTrack;\n    activeSub = this;\n    shouldTrack = true;\n    try {\n      return this.fn();\n    } finally {\n      if (!!(process.env.NODE_ENV !== \"production\") && activeSub !== this) {\n        warn(\"Active effect was not restored correctly - this is likely a Vue internal bug.\");\n      }\n      cleanupDeps(this);\n      activeSub = prevEffect;\n      shouldTrack = prevShouldTrack;\n      this.flags &= -3;\n    }\n  }\n  stop() {\n    if (this.flags & 1) {\n      for (let link = this.deps; link; link = link.nextDep) {\n        removeSub(link);\n      }\n      this.deps = this.depsTail = void 0;\n      cleanupEffect(this);\n      this.onStop && this.onStop();\n      this.flags &= -2;\n    }\n  }\n  trigger() {\n    if (this.flags & 64) {\n      pausedQueueEffects.add(this);\n    } else if (this.scheduler) {\n      this.scheduler();\n    } else {\n      this.runIfDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n  runIfDirty() {\n    if (isDirty(this)) {\n      this.run();\n    }\n  }\n  get dirty() {\n    return isDirty(this);\n  }\n}\nlet batchDepth = 0;\nlet batchedSub;\nlet batchedComputed;\nfunction batch(sub, isComputed = false) {\n  sub.flags |= 8;\n  if (isComputed) {\n    sub.next = batchedComputed;\n    batchedComputed = sub;\n    return;\n  }\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\nfunction startBatch() {\n  batchDepth++;\n}\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n  if (batchedComputed) {\n    let e = batchedComputed;\n    batchedComputed = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= -9;\n      e = next;\n    }\n  }\n  let error;\n  while (batchedSub) {\n    let e = batchedSub;\n    batchedSub = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= -9;\n      if (e.flags & 1) {\n        try {\n          ;\n          e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n      e = next;\n    }\n  }\n  if (error) throw error;\n}\nfunction prepareDeps(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\nfunction cleanupDeps(sub) {\n  let head;\n  let tail = sub.depsTail;\n  let link = tail;\n  while (link) {\n    const prev = link.prevDep;\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = void 0;\n    link = prev;\n  }\n  sub.deps = head;\n  sub.depsTail = tail;\n}\nfunction isDirty(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n  if (sub._dirty) {\n    return true;\n  }\n  return false;\n}\nfunction refreshComputed(computed) {\n  if (computed.flags & 4 && !(computed.flags & 16)) {\n    return;\n  }\n  computed.flags &= -17;\n  if (computed.globalVersion === globalVersion) {\n    return;\n  }\n  computed.globalVersion = globalVersion;\n  if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) {\n    return;\n  }\n  computed.flags |= 2;\n  const dep = computed.dep;\n  const prevSub = activeSub;\n  const prevShouldTrack = shouldTrack;\n  activeSub = computed;\n  shouldTrack = true;\n  try {\n    prepareDeps(computed);\n    const value = computed.fn(computed._value);\n    if (dep.version === 0 || hasChanged(value, computed._value)) {\n      computed.flags |= 128;\n      computed._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed);\n    computed.flags &= -3;\n  }\n}\nfunction removeSub(link, soft = false) {\n  const {\n    dep,\n    prevSub,\n    nextSub\n  } = link;\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = void 0;\n  }\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = void 0;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n    if (!prevSub && dep.computed) {\n      dep.computed.flags &= -5;\n      for (let l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    }\n  }\n  if (!soft && ! --dep.sc && dep.map) {\n    dep.map.delete(dep.key);\n  }\n}\nfunction removeDep(link) {\n  const {\n    prevDep,\n    nextDep\n  } = link;\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = void 0;\n  }\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = void 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const e = new ReactiveEffect(fn);\n  if (options) {\n    extend(e, options);\n  }\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n  const runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction onEffectCleanup(fn, failSilently = false) {\n  if (activeSub instanceof ReactiveEffect) {\n    activeSub.cleanup = fn;\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(`onEffectCleanup() was called when there was no active effect to associate with.`);\n  }\n}\nfunction cleanupEffect(e) {\n  const {\n    cleanup\n  } = e;\n  e.cleanup = void 0;\n  if (cleanup) {\n    const prevSub = activeSub;\n    activeSub = void 0;\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\nlet globalVersion = 0;\nclass Link {\n  constructor(sub, dep) {\n    this.sub = sub;\n    this.dep = dep;\n    this.version = dep.version;\n    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;\n  }\n}\nclass Dep {\n  // TODO isolatedDeclarations \"__v_skip\"\n  constructor(computed) {\n    this.computed = computed;\n    this.version = 0;\n    /**\n     * Link between this dep and the current active effect\n     */\n    this.activeLink = void 0;\n    /**\n     * Doubly linked list representing the subscribing effects (tail)\n     */\n    this.subs = void 0;\n    /**\n     * For object property deps cleanup\n     */\n    this.map = void 0;\n    this.key = void 0;\n    /**\n     * Subscriber counter\n     */\n    this.sc = 0;\n    /**\n     * @internal\n     */\n    this.__v_skip = true;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.subsHead = void 0;\n    }\n  }\n  track(debugInfo) {\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n    let link = this.activeLink;\n    if (link === void 0 || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n      }\n      addSub(link);\n    } else if (link.version === -1) {\n      link.version = this.version;\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n        if (link.prevDep) {\n          link.prevDep.nextDep = next;\n        }\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = void 0;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n        if (activeSub.deps === link) {\n          activeSub.deps = next;\n        }\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && activeSub.onTrack) {\n      activeSub.onTrack(extend({\n        effect: activeSub\n      }, debugInfo));\n    }\n    return link;\n  }\n  trigger(debugInfo) {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n  notify(debugInfo) {\n    startBatch();\n    try {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        for (let head = this.subsHead; head; head = head.nextSub) {\n          if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n            head.sub.onTrigger(extend({\n              effect: head.sub\n            }, debugInfo));\n          }\n        }\n      }\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          ;\n          link.sub.dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n}\nfunction addSub(link) {\n  link.dep.sc++;\n  if (link.sub.flags & 4) {\n    const computed = link.dep.computed;\n    if (computed && !link.dep.subs) {\n      computed.flags |= 4 | 16;\n      for (let l = computed.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n    const currentTail = link.dep.subs;\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && link.dep.subsHead === void 0) {\n      link.dep.subsHead = link;\n    }\n    link.dep.subs = link;\n  }\n}\nconst targetMap = /* @__PURE__ */new WeakMap();\nconst ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Object iterate\" : \"\");\nconst MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Map keys iterate\" : \"\");\nconst ARRAY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Array iterate\" : \"\");\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      dep.track({\n        target,\n        type,\n        key\n      });\n    } else {\n      dep.track();\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n  const run = dep => {\n    if (dep) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        dep.trigger({\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      } else {\n        dep.trigger();\n      }\n    }\n  };\n  startBatch();\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    const targetIsArray = isArray(target);\n    const isArrayIndex = targetIsArray && isIntegerKey(key);\n    if (targetIsArray && key === \"length\") {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== void 0 || depsMap.has(void 0)) {\n        run(depsMap.get(key));\n      }\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (isMap(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n  }\n  endBatch();\n}\nfunction getDepFromReactive(object, key) {\n  const depMap = targetMap.get(object);\n  return depMap && depMap.get(key);\n}\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\nfunction toWrapped(target, item) {\n  if (isReadonly(target)) {\n    return isReactive(target) ? toReadonly(toReactive(item)) : toReadonly(item);\n  }\n  return toReactive(item);\n}\nconst arrayInstrumentations = {\n  __proto__: null,\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, item => toWrapped(this, item));\n  },\n  concat(...args) {\n    return reactiveReadArray(this).concat(...args.map(x => isArray(x) ? reactiveReadArray(x) : x));\n  },\n  entries() {\n    return iterator(this, \"entries\", value => {\n      value[1] = toWrapped(this, value[1]);\n      return value;\n    });\n  },\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, void 0, arguments);\n  },\n  filter(fn, thisArg) {\n    return apply(this, \"filter\", fn, thisArg, v => v.map(item => toWrapped(this, item)), arguments);\n  },\n  find(fn, thisArg) {\n    return apply(this, \"find\", fn, thisArg, item => toWrapped(this, item), arguments);\n  },\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n  },\n  findLast(fn, thisArg) {\n    return apply(this, \"findLast\", fn, thisArg, item => toWrapped(this, item), arguments);\n  },\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n  },\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n  },\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n  // keys() iterator only reads `length`, no optimization required\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, void 0, arguments);\n  },\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, void 0, arguments);\n  },\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n  values() {\n    return iterator(this, \"values\", item => toWrapped(this, item));\n  }\n};\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n    iter.next = () => {\n      const result = iter._next();\n      if (!result.done) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nconst arrayProto = Array.prototype;\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self && !isShallow(self);\n  const methodFn = arr[method];\n  if (methodFn !== arrayProto[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function (item, index) {\n        return fn.call(this, toWrapped(self, item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function (item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function (acc, item, index) {\n        return fn.call(this, acc, toWrapped(self, item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function (acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n  return arr[method](wrappedFn, ...args);\n}\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n  return res;\n}\nfunction noTracking(self, method, args = []) {\n  pauseTracking();\n  startBatch();\n  const res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\nconst isNonTrackableKeys = /* @__PURE__ */makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(/* @__PURE__ */Object.getOwnPropertyNames(Symbol).filter(key => key !== \"arguments\" && key !== \"caller\").map(key => Symbol[key]).filter(isSymbol));\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key)) key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  get(target, key, receiver) {\n    if (key === \"__v_skip\") return target[\"__v_skip\"];\n    const isReadonly2 = this._isReadonly,\n      isShallow2 = this._isShallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) ||\n      // receiver is not the reactive proxy, but has the same prototype\n      // this means the receiver is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      let fn;\n      if (targetIsArray && (fn = arrayInstrumentations[key])) {\n        return fn;\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(target, key,\n    // if this is a proxy wrapping a ref, return methods using the raw ref\n    // as receiver so that we don't have to call `toRaw` on the ref in all\n    // its class methods\n    isRef(target) ? target : receiver);\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (isShallow2) {\n      return res;\n    }\n    if (isRef(res)) {\n      const value = targetIsArray && isIntegerKey(key) ? res : res.value;\n      return isReadonly2 && isObject(value) ? readonly(value) : value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    const isArrayWithIntegerKey = isArray(target) && isIntegerKey(key);\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArrayWithIntegerKey && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target[key]);\n          }\n          return true;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = isArrayWithIntegerKey ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, isRef(target) ? target : receiver);\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(target, \"iterate\", isArray(target) ? \"length\" : ITERATE_KEY);\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */new ReadonlyReactiveHandler(true);\nconst toShallow = value => value;\nconst getProto = v => Reflect.getPrototypeOf(v);\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function (...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(rawTarget, \"iterate\", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    return {\n      // iterator protocol\n      next() {\n        const {\n          value,\n          done\n        } = innerIterator.next();\n        return done ? {\n          value,\n          done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function (...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations(readonly, shallow) {\n  const instrumentations = {\n    get(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"get\", key);\n        }\n        track(rawTarget, \"get\", rawKey);\n      }\n      const {\n        has\n      } = getProto(rawTarget);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n    get size() {\n      const target = this[\"__v_raw\"];\n      !readonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n      return target.size;\n    },\n    has(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"has\", key);\n        }\n        track(rawTarget, \"has\", rawKey);\n      }\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n    forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      !readonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    }\n  };\n  extend(instrumentations, readonly ? {\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\")\n  } : {\n    add(value) {\n      if (!shallow && !isShallow(value) && !isReadonly(value)) {\n        value = toRaw(value);\n      }\n      const target = toRaw(this);\n      const proto = getProto(target);\n      const hadKey = proto.has.call(target, value);\n      if (!hadKey) {\n        target.add(value);\n        trigger(target, \"add\", value, value);\n      }\n      return this;\n    },\n    set(key, value) {\n      if (!shallow && !isShallow(value) && !isReadonly(value)) {\n        value = toRaw(value);\n      }\n      const target = toRaw(this);\n      const {\n        has,\n        get\n      } = getProto(target);\n      let hadKey = has.call(target, key);\n      if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n      } else if (!!(process.env.NODE_ENV !== \"production\")) {\n        checkIdentityKeys(target, has, key);\n      }\n      const oldValue = get.call(target, key);\n      target.set(key, value);\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n      return this;\n    },\n    delete(key) {\n      const target = toRaw(this);\n      const {\n        has,\n        get\n      } = getProto(target);\n      let hadKey = has.call(target, key);\n      if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n      } else if (!!(process.env.NODE_ENV !== \"production\")) {\n        checkIdentityKeys(target, has, key);\n      }\n      const oldValue = get ? get.call(target, key) : void 0;\n      const result = target.delete(key);\n      if (hadKey) {\n        trigger(target, \"delete\", key, void 0, oldValue);\n      }\n      return result;\n    },\n    clear() {\n      const target = toRaw(this);\n      const hadItems = target.size !== 0;\n      const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n      const result = target.clear();\n      if (hadItems) {\n        trigger(target, \"clear\", void 0, void 0, oldTarget);\n      }\n      return result;\n    }\n  });\n  const iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach(method => {\n    instrumentations[method] = createIterableMethod(method, readonly, shallow);\n  });\n  return instrumentations;\n}\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  const instrumentations = createInstrumentations(isReadonly2, shallow);\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);\n  }\n}\nconst reactiveMap = /* @__PURE__ */new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */new WeakMap();\nconst readonlyMap = /* @__PURE__ */new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`value cannot be made ${isReadonly2 ? \"readonly\" : \"reactive\"}: ${String(target)}`);\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (!hasOwn(value, \"__v_skip\") && Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = value => isObject(value) ? reactive(value) : value;\nconst toReadonly = value => isObject(value) ? readonly(value) : value;\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, isShallow2) {\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n  get value() {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      this.dep.track();\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    const oldValue = this._rawValue;\n    const useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n    newValue = useDirectValue ? newValue : toRaw(newValue);\n    if (hasChanged(newValue, oldValue)) {\n      this._rawValue = newValue;\n      this._value = useDirectValue ? newValue : toReactive(newValue);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        this.dep.trigger({\n          target: this,\n          type: \"set\",\n          key: \"value\",\n          newValue,\n          oldValue\n        });\n      } else {\n        this.dep.trigger();\n      }\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    } else {\n      ref2.dep.trigger();\n    }\n  }\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    const dep = this.dep = new Dep();\n    const {\n      get,\n      set\n    } = factory(dep.track.bind(dep), dep.trigger.bind(dep));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._value = this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    this._raw = toRaw(_object);\n    let shallow = true;\n    let obj = _object;\n    if (!isArray(_object) || !isIntegerKey(String(_key))) {\n      do {\n        shallow = !isProxy(obj) || isShallow(obj);\n      } while (shallow && (obj = obj[\"__v_raw\"]));\n    }\n    this._shallow = shallow;\n  }\n  get value() {\n    let val = this._object[this._key];\n    if (this._shallow) {\n      val = unref(val);\n    }\n    return this._value = val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    if (this._shallow && isRef(this._raw[this._key])) {\n      const nestedRef = this._object[this._key];\n      if (isRef(nestedRef)) {\n        nestedRef.value = newVal;\n        return;\n      }\n    }\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(this._raw, this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    return this._value = this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  return new ObjectRefImpl(source, key, defaultValue);\n}\nclass ComputedRefImpl {\n  constructor(fn, setter, isSSR) {\n    this.fn = fn;\n    this.setter = setter;\n    /**\n     * @internal\n     */\n    this._value = void 0;\n    /**\n     * @internal\n     */\n    this.dep = new Dep(this);\n    /**\n     * @internal\n     */\n    this.__v_isRef = true;\n    // TODO isolatedDeclarations \"__v_isReadonly\"\n    // A computed is also a subscriber that tracks other deps\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 16;\n    /**\n     * @internal\n     */\n    this.globalVersion = globalVersion - 1;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    // for backwards compat\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    this.flags |= 16;\n    if (!(this.flags & 8) &&\n    // avoid infinite self recursion\n    activeSub !== this) {\n      batch(this, true);\n      return true;\n    } else if (!!(process.env.NODE_ENV !== \"production\")) ;\n  }\n  get value() {\n    const link = !!(process.env.NODE_ENV !== \"production\") ? this.dep.track({\n      target: this,\n      type: \"get\",\n      key: \"value\"\n    }) : this.dep.track();\n    refreshComputed(this);\n    if (link) {\n      link.version = this.dep.version;\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\"Write operation failed: computed value is readonly\");\n    }\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\",\n  \"IS_REF\": \"__v_isRef\"\n};\nconst WatchErrorCodes = {\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\"\n};\nconst INITIAL_WATCHER_VALUE = {};\nconst cleanupMap = /* @__PURE__ */new WeakMap();\nlet activeWatcher = void 0;\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\nfunction onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {\n  if (owner) {\n    let cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(`onWatcherCleanup() was called when there was no active watcher to associate with.`);\n  }\n}\nfunction watch(source, cb, options = EMPTY_OBJ) {\n  const {\n    immediate,\n    deep,\n    once,\n    scheduler,\n    augmentJob,\n    call\n  } = options;\n  const warnInvalidSource = s => {\n    (options.onWarn || warn)(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);\n  };\n  const reactiveGetter = source2 => {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0) return traverse(source2, 1);\n    return traverse(source2);\n  };\n  let effect;\n  let getter;\n  let cleanup;\n  let boundCleanup;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some(s => isReactive(s) || isShallow(s));\n    getter = () => source.map(s => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if (isFunction(s)) {\n        return call ? call(s, 2) : s();\n      } else {\n        !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      getter = call ? () => call(source, 2) : source;\n    } else {\n      getter = () => {\n        if (cleanup) {\n          pauseTracking();\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n        const currentEffect = activeWatcher;\n        activeWatcher = effect;\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = NOOP;\n    !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    const depth = deep === true ? Infinity : deep;\n    getter = () => traverse(baseGetter(), depth);\n  }\n  const scope = getCurrentScope();\n  const watchHandle = () => {\n    effect.stop();\n    if (scope && scope.active) {\n      remove(scope.effects, effect);\n    }\n  };\n  if (once && cb) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      watchHandle();\n    };\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = immediateFirstRun => {\n    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n        const currentWatcher = activeWatcher;\n        activeWatcher = effect;\n        try {\n          const args = [newValue,\n          // pass undefined as the old value when it's changed for the first time\n          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue, boundCleanup];\n          oldValue = newValue;\n          call ? call(cb, 3, args) :\n          // @ts-expect-error\n          cb(...args);\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect.run();\n    }\n  };\n  if (augmentJob) {\n    augmentJob(job);\n  }\n  effect = new ReactiveEffect(getter);\n  effect.scheduler = scheduler ? () => scheduler(job, false) : job;\n  boundCleanup = fn => onWatcherCleanup(fn, false, effect);\n  cleanup = effect.onStop = () => {\n    const cleanups = cleanupMap.get(effect);\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        for (const cleanup2 of cleanups) cleanup2();\n      }\n      cleanupMap.delete(effect);\n    }\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    effect.onTrack = options.onTrack;\n    effect.onTrigger = options.onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect.run();\n  }\n  watchHandle.pause = effect.pause.bind(effect);\n  watchHandle.resume = effect.resume.bind(effect);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */new Map();\n  if ((seen.get(value) || 0) >= depth) {\n    return value;\n  }\n  seen.set(value, depth);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach(v => {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n      if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n        traverse(value[key], depth, seen);\n      }\n    }\n  }\n  return value;\n}\nexport { ARRAY_ITERATE_KEY, EffectFlags, EffectScope, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, WatchErrorCodes, computed, customRef, effect, effectScope, enableTracking, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onEffectCleanup, onScopeDispose, onWatcherCleanup, pauseTracking, proxyRefs, reactive, reactiveReadArray, readonly, ref, resetTracking, shallowReactive, shallowReadArray, shallowReadonly, shallowRef, stop, toRaw, toReactive, toReadonly, toRef, toRefs, toValue, track, traverse, trigger, triggerRef, unref, watch };","map":{"version":3,"names":["extend","hasChanged","isArray","isIntegerKey","isSymbol","isMap","hasOwn","makeMap","isObject","capitalize","toRawType","def","isFunction","EMPTY_OBJ","isSet","isPlainObject","remove","NOOP","warn","msg","args","console","activeEffectScope","EffectScope","constructor","detached","_active","_on","effects","cleanups","_isPaused","parent","index","scopes","push","active","pause","i","l","length","resume","run","fn","currentEffectScope","process","env","NODE_ENV","on","prevScope","off","stop","fromParent","last","pop","effectScope","getCurrentScope","onScopeDispose","failSilently","activeSub","EffectFlags","pausedQueueEffects","WeakSet","ReactiveEffect","deps","depsTail","flags","next","cleanup","scheduler","has","delete","trigger","notify","batch","cleanupEffect","prepareDeps","prevEffect","prevShouldTrack","shouldTrack","cleanupDeps","link","nextDep","removeSub","onStop","add","runIfDirty","isDirty","dirty","batchDepth","batchedSub","batchedComputed","sub","isComputed","startBatch","endBatch","e","error","err","version","prevActiveLink","dep","activeLink","head","tail","prev","prevDep","removeDep","computed","refreshComputed","_dirty","globalVersion","isSSR","prevSub","value","_value","soft","nextSub","subsHead","subs","sc","map","key","effect","options","runner","bind","trackStack","pauseTracking","enableTracking","resetTracking","onEffectCleanup","Link","Dep","__v_skip","track","debugInfo","addSub","onTrack","onTrigger","currentTail","targetMap","WeakMap","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ARRAY_ITERATE_KEY","target","type","depsMap","get","set","Map","newValue","oldValue","oldTarget","forEach","targetIsArray","isArrayIndex","newLength","Number","key2","getDepFromReactive","object","depMap","reactiveReadArray","array","raw","toRaw","isShallow","toReactive","shallowReadArray","arr","toWrapped","item","isReadonly","isReactive","toReadonly","arrayInstrumentations","__proto__","iterator","concat","x","entries","every","thisArg","apply","arguments","filter","v","find","findIndex","findLast","findLastIndex","includes","searchProxy","indexOf","join","separator","lastIndexOf","noTracking","reduce","reduceRight","shift","some","splice","toReversed","toSorted","comparer","toSpliced","unshift","values","self","method","wrapValue","iter","_next","result","done","arrayProto","Array","prototype","wrappedRetFn","needsWrap","methodFn","result2","wrappedFn","call","acc","res","isProxy","isNonTrackableKeys","builtInSymbols","Set","Object","getOwnPropertyNames","hasOwnProperty","String","obj","BaseReactiveHandler","_isReadonly","_isShallow","receiver","isReadonly2","isShallow2","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","getPrototypeOf","Reflect","isRef","readonly","reactive","MutableReactiveHandler","isArrayWithIntegerKey","isOldValueReadonly","hadKey","deleteProperty","ownKeys","ReadonlyReactiveHandler","mutableHandlers","readonlyHandlers","shallowReactiveHandlers","shallowReadonlyHandlers","toShallow","getProto","createIterableMethod","rawTarget","targetIsMap","isPair","isKeyOnly","innerIterator","wrap","createReadonlyMethod","createInstrumentations","shallow","instrumentations","rawKey","size","callback","observed","clear","proto","checkIdentityKeys","hadItems","iteratorMethods","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","targetType","existingProxy","proxy","Proxy","markRaw","r","ref","createRef","shallowRef","rawValue","RefImpl","_rawValue","useDirectValue","triggerRef","ref2","unref","toValue","source","shallowUnwrapHandlers","proxyRefs","objectWithRefs","CustomRefImpl","factory","_get","_set","newVal","customRef","toRefs","ret","propertyToRef","ObjectRefImpl","_object","_key","_defaultValue","_raw","_shallow","val","nestedRef","GetterRefImpl","_getter","toRef","defaultValue","ComputedRefImpl","setter","__v_isRef","getterOrOptions","debugOptions","getter","cRef","TrackOpTypes","TriggerOpTypes","ReactiveFlags","WatchErrorCodes","INITIAL_WATCHER_VALUE","cleanupMap","activeWatcher","getCurrentWatcher","onWatcherCleanup","cleanupFn","owner","watch","cb","immediate","deep","once","augmentJob","warnInvalidSource","s","onWarn","reactiveGetter","source2","traverse","boundCleanup","forceTrigger","isMultiSource","currentEffect","baseGetter","depth","Infinity","scope","watchHandle","_cb","fill","job","immediateFirstRun","currentWatcher","cleanup2","seen","getOwnPropertySymbols","propertyIsEnumerable"],"sources":["D:/developData/testCode/YYQ-1126/frontend/blog/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"],"sourcesContent":["/**\n* @vue/reactivity v3.5.25\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { extend, hasChanged, isArray, isIntegerKey, isSymbol, isMap, hasOwn, makeMap, isObject, capitalize, toRawType, def, isFunction, EMPTY_OBJ, isSet, isPlainObject, remove, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal track `on` calls, allow `on` call multiple times\n     */\n    this._on = 0;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this._isPaused = false;\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  pause() {\n    if (this._active) {\n      this._isPaused = true;\n      let i, l;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].pause();\n        }\n      }\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].pause();\n      }\n    }\n  }\n  /**\n   * Resumes the effect scope, including all child scopes and effects.\n   */\n  resume() {\n    if (this._active) {\n      if (this._isPaused) {\n        this._isPaused = false;\n        let i, l;\n        if (this.scopes) {\n          for (i = 0, l = this.scopes.length; i < l; i++) {\n            this.scopes[i].resume();\n          }\n        }\n        for (i = 0, l = this.effects.length; i < l; i++) {\n          this.effects[i].resume();\n        }\n      }\n    }\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    if (++this._on === 1) {\n      this.prevScope = activeEffectScope;\n      activeEffectScope = this;\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    if (this._on > 0 && --this._on === 0) {\n      activeEffectScope = this.prevScope;\n      this.prevScope = void 0;\n    }\n  }\n  stop(fromParent) {\n    if (this._active) {\n      this._active = false;\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      this.effects.length = 0;\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      this.cleanups.length = 0;\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n        this.scopes.length = 0;\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn, failSilently = false) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nlet activeSub;\nconst EffectFlags = {\n  \"ACTIVE\": 1,\n  \"1\": \"ACTIVE\",\n  \"RUNNING\": 2,\n  \"2\": \"RUNNING\",\n  \"TRACKING\": 4,\n  \"4\": \"TRACKING\",\n  \"NOTIFIED\": 8,\n  \"8\": \"NOTIFIED\",\n  \"DIRTY\": 16,\n  \"16\": \"DIRTY\",\n  \"ALLOW_RECURSE\": 32,\n  \"32\": \"ALLOW_RECURSE\",\n  \"PAUSED\": 64,\n  \"64\": \"PAUSED\",\n  \"EVALUATED\": 128,\n  \"128\": \"EVALUATED\"\n};\nconst pausedQueueEffects = /* @__PURE__ */ new WeakSet();\nclass ReactiveEffect {\n  constructor(fn) {\n    this.fn = fn;\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 1 | 4;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    /**\n     * @internal\n     */\n    this.cleanup = void 0;\n    this.scheduler = void 0;\n    if (activeEffectScope && activeEffectScope.active) {\n      activeEffectScope.effects.push(this);\n    }\n  }\n  pause() {\n    this.flags |= 64;\n  }\n  resume() {\n    if (this.flags & 64) {\n      this.flags &= -65;\n      if (pausedQueueEffects.has(this)) {\n        pausedQueueEffects.delete(this);\n        this.trigger();\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    if (this.flags & 2 && !(this.flags & 32)) {\n      return;\n    }\n    if (!(this.flags & 8)) {\n      batch(this);\n    }\n  }\n  run() {\n    if (!(this.flags & 1)) {\n      return this.fn();\n    }\n    this.flags |= 2;\n    cleanupEffect(this);\n    prepareDeps(this);\n    const prevEffect = activeSub;\n    const prevShouldTrack = shouldTrack;\n    activeSub = this;\n    shouldTrack = true;\n    try {\n      return this.fn();\n    } finally {\n      if (!!(process.env.NODE_ENV !== \"production\") && activeSub !== this) {\n        warn(\n          \"Active effect was not restored correctly - this is likely a Vue internal bug.\"\n        );\n      }\n      cleanupDeps(this);\n      activeSub = prevEffect;\n      shouldTrack = prevShouldTrack;\n      this.flags &= -3;\n    }\n  }\n  stop() {\n    if (this.flags & 1) {\n      for (let link = this.deps; link; link = link.nextDep) {\n        removeSub(link);\n      }\n      this.deps = this.depsTail = void 0;\n      cleanupEffect(this);\n      this.onStop && this.onStop();\n      this.flags &= -2;\n    }\n  }\n  trigger() {\n    if (this.flags & 64) {\n      pausedQueueEffects.add(this);\n    } else if (this.scheduler) {\n      this.scheduler();\n    } else {\n      this.runIfDirty();\n    }\n  }\n  /**\n   * @internal\n   */\n  runIfDirty() {\n    if (isDirty(this)) {\n      this.run();\n    }\n  }\n  get dirty() {\n    return isDirty(this);\n  }\n}\nlet batchDepth = 0;\nlet batchedSub;\nlet batchedComputed;\nfunction batch(sub, isComputed = false) {\n  sub.flags |= 8;\n  if (isComputed) {\n    sub.next = batchedComputed;\n    batchedComputed = sub;\n    return;\n  }\n  sub.next = batchedSub;\n  batchedSub = sub;\n}\nfunction startBatch() {\n  batchDepth++;\n}\nfunction endBatch() {\n  if (--batchDepth > 0) {\n    return;\n  }\n  if (batchedComputed) {\n    let e = batchedComputed;\n    batchedComputed = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= -9;\n      e = next;\n    }\n  }\n  let error;\n  while (batchedSub) {\n    let e = batchedSub;\n    batchedSub = void 0;\n    while (e) {\n      const next = e.next;\n      e.next = void 0;\n      e.flags &= -9;\n      if (e.flags & 1) {\n        try {\n          ;\n          e.trigger();\n        } catch (err) {\n          if (!error) error = err;\n        }\n      }\n      e = next;\n    }\n  }\n  if (error) throw error;\n}\nfunction prepareDeps(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    link.version = -1;\n    link.prevActiveLink = link.dep.activeLink;\n    link.dep.activeLink = link;\n  }\n}\nfunction cleanupDeps(sub) {\n  let head;\n  let tail = sub.depsTail;\n  let link = tail;\n  while (link) {\n    const prev = link.prevDep;\n    if (link.version === -1) {\n      if (link === tail) tail = prev;\n      removeSub(link);\n      removeDep(link);\n    } else {\n      head = link;\n    }\n    link.dep.activeLink = link.prevActiveLink;\n    link.prevActiveLink = void 0;\n    link = prev;\n  }\n  sub.deps = head;\n  sub.depsTail = tail;\n}\nfunction isDirty(sub) {\n  for (let link = sub.deps; link; link = link.nextDep) {\n    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {\n      return true;\n    }\n  }\n  if (sub._dirty) {\n    return true;\n  }\n  return false;\n}\nfunction refreshComputed(computed) {\n  if (computed.flags & 4 && !(computed.flags & 16)) {\n    return;\n  }\n  computed.flags &= -17;\n  if (computed.globalVersion === globalVersion) {\n    return;\n  }\n  computed.globalVersion = globalVersion;\n  if (!computed.isSSR && computed.flags & 128 && (!computed.deps && !computed._dirty || !isDirty(computed))) {\n    return;\n  }\n  computed.flags |= 2;\n  const dep = computed.dep;\n  const prevSub = activeSub;\n  const prevShouldTrack = shouldTrack;\n  activeSub = computed;\n  shouldTrack = true;\n  try {\n    prepareDeps(computed);\n    const value = computed.fn(computed._value);\n    if (dep.version === 0 || hasChanged(value, computed._value)) {\n      computed.flags |= 128;\n      computed._value = value;\n      dep.version++;\n    }\n  } catch (err) {\n    dep.version++;\n    throw err;\n  } finally {\n    activeSub = prevSub;\n    shouldTrack = prevShouldTrack;\n    cleanupDeps(computed);\n    computed.flags &= -3;\n  }\n}\nfunction removeSub(link, soft = false) {\n  const { dep, prevSub, nextSub } = link;\n  if (prevSub) {\n    prevSub.nextSub = nextSub;\n    link.prevSub = void 0;\n  }\n  if (nextSub) {\n    nextSub.prevSub = prevSub;\n    link.nextSub = void 0;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && dep.subsHead === link) {\n    dep.subsHead = nextSub;\n  }\n  if (dep.subs === link) {\n    dep.subs = prevSub;\n    if (!prevSub && dep.computed) {\n      dep.computed.flags &= -5;\n      for (let l = dep.computed.deps; l; l = l.nextDep) {\n        removeSub(l, true);\n      }\n    }\n  }\n  if (!soft && !--dep.sc && dep.map) {\n    dep.map.delete(dep.key);\n  }\n}\nfunction removeDep(link) {\n  const { prevDep, nextDep } = link;\n  if (prevDep) {\n    prevDep.nextDep = nextDep;\n    link.prevDep = void 0;\n  }\n  if (nextDep) {\n    nextDep.prevDep = prevDep;\n    link.nextDep = void 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const e = new ReactiveEffect(fn);\n  if (options) {\n    extend(e, options);\n  }\n  try {\n    e.run();\n  } catch (err) {\n    e.stop();\n    throw err;\n  }\n  const runner = e.run.bind(e);\n  runner.effect = e;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction onEffectCleanup(fn, failSilently = false) {\n  if (activeSub instanceof ReactiveEffect) {\n    activeSub.cleanup = fn;\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onEffectCleanup() was called when there was no active effect to associate with.`\n    );\n  }\n}\nfunction cleanupEffect(e) {\n  const { cleanup } = e;\n  e.cleanup = void 0;\n  if (cleanup) {\n    const prevSub = activeSub;\n    activeSub = void 0;\n    try {\n      cleanup();\n    } finally {\n      activeSub = prevSub;\n    }\n  }\n}\n\nlet globalVersion = 0;\nclass Link {\n  constructor(sub, dep) {\n    this.sub = sub;\n    this.dep = dep;\n    this.version = dep.version;\n    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;\n  }\n}\nclass Dep {\n  // TODO isolatedDeclarations \"__v_skip\"\n  constructor(computed) {\n    this.computed = computed;\n    this.version = 0;\n    /**\n     * Link between this dep and the current active effect\n     */\n    this.activeLink = void 0;\n    /**\n     * Doubly linked list representing the subscribing effects (tail)\n     */\n    this.subs = void 0;\n    /**\n     * For object property deps cleanup\n     */\n    this.map = void 0;\n    this.key = void 0;\n    /**\n     * Subscriber counter\n     */\n    this.sc = 0;\n    /**\n     * @internal\n     */\n    this.__v_skip = true;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.subsHead = void 0;\n    }\n  }\n  track(debugInfo) {\n    if (!activeSub || !shouldTrack || activeSub === this.computed) {\n      return;\n    }\n    let link = this.activeLink;\n    if (link === void 0 || link.sub !== activeSub) {\n      link = this.activeLink = new Link(activeSub, this);\n      if (!activeSub.deps) {\n        activeSub.deps = activeSub.depsTail = link;\n      } else {\n        link.prevDep = activeSub.depsTail;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n      }\n      addSub(link);\n    } else if (link.version === -1) {\n      link.version = this.version;\n      if (link.nextDep) {\n        const next = link.nextDep;\n        next.prevDep = link.prevDep;\n        if (link.prevDep) {\n          link.prevDep.nextDep = next;\n        }\n        link.prevDep = activeSub.depsTail;\n        link.nextDep = void 0;\n        activeSub.depsTail.nextDep = link;\n        activeSub.depsTail = link;\n        if (activeSub.deps === link) {\n          activeSub.deps = next;\n        }\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && activeSub.onTrack) {\n      activeSub.onTrack(\n        extend(\n          {\n            effect: activeSub\n          },\n          debugInfo\n        )\n      );\n    }\n    return link;\n  }\n  trigger(debugInfo) {\n    this.version++;\n    globalVersion++;\n    this.notify(debugInfo);\n  }\n  notify(debugInfo) {\n    startBatch();\n    try {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        for (let head = this.subsHead; head; head = head.nextSub) {\n          if (head.sub.onTrigger && !(head.sub.flags & 8)) {\n            head.sub.onTrigger(\n              extend(\n                {\n                  effect: head.sub\n                },\n                debugInfo\n              )\n            );\n          }\n        }\n      }\n      for (let link = this.subs; link; link = link.prevSub) {\n        if (link.sub.notify()) {\n          ;\n          link.sub.dep.notify();\n        }\n      }\n    } finally {\n      endBatch();\n    }\n  }\n}\nfunction addSub(link) {\n  link.dep.sc++;\n  if (link.sub.flags & 4) {\n    const computed = link.dep.computed;\n    if (computed && !link.dep.subs) {\n      computed.flags |= 4 | 16;\n      for (let l = computed.deps; l; l = l.nextDep) {\n        addSub(l);\n      }\n    }\n    const currentTail = link.dep.subs;\n    if (currentTail !== link) {\n      link.prevSub = currentTail;\n      if (currentTail) currentTail.nextSub = link;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && link.dep.subsHead === void 0) {\n      link.dep.subsHead = link;\n    }\n    link.dep.subs = link;\n  }\n}\nconst targetMap = /* @__PURE__ */ new WeakMap();\nconst ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Object iterate\" : \"\"\n);\nconst MAP_KEY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Map keys iterate\" : \"\"\n);\nconst ARRAY_ITERATE_KEY = Symbol(\n  !!(process.env.NODE_ENV !== \"production\") ? \"Array iterate\" : \"\"\n);\nfunction track(target, type, key) {\n  if (shouldTrack && activeSub) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = new Dep());\n      dep.map = depsMap;\n      dep.key = key;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      dep.track({\n        target,\n        type,\n        key\n      });\n    } else {\n      dep.track();\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    globalVersion++;\n    return;\n  }\n  const run = (dep) => {\n    if (dep) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        dep.trigger({\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        });\n      } else {\n        dep.trigger();\n      }\n    }\n  };\n  startBatch();\n  if (type === \"clear\") {\n    depsMap.forEach(run);\n  } else {\n    const targetIsArray = isArray(target);\n    const isArrayIndex = targetIsArray && isIntegerKey(key);\n    if (targetIsArray && key === \"length\") {\n      const newLength = Number(newValue);\n      depsMap.forEach((dep, key2) => {\n        if (key2 === \"length\" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {\n          run(dep);\n        }\n      });\n    } else {\n      if (key !== void 0 || depsMap.has(void 0)) {\n        run(depsMap.get(key));\n      }\n      if (isArrayIndex) {\n        run(depsMap.get(ARRAY_ITERATE_KEY));\n      }\n      switch (type) {\n        case \"add\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          } else if (isArrayIndex) {\n            run(depsMap.get(\"length\"));\n          }\n          break;\n        case \"delete\":\n          if (!targetIsArray) {\n            run(depsMap.get(ITERATE_KEY));\n            if (isMap(target)) {\n              run(depsMap.get(MAP_KEY_ITERATE_KEY));\n            }\n          }\n          break;\n        case \"set\":\n          if (isMap(target)) {\n            run(depsMap.get(ITERATE_KEY));\n          }\n          break;\n      }\n    }\n  }\n  endBatch();\n}\nfunction getDepFromReactive(object, key) {\n  const depMap = targetMap.get(object);\n  return depMap && depMap.get(key);\n}\n\nfunction reactiveReadArray(array) {\n  const raw = toRaw(array);\n  if (raw === array) return raw;\n  track(raw, \"iterate\", ARRAY_ITERATE_KEY);\n  return isShallow(array) ? raw : raw.map(toReactive);\n}\nfunction shallowReadArray(arr) {\n  track(arr = toRaw(arr), \"iterate\", ARRAY_ITERATE_KEY);\n  return arr;\n}\nfunction toWrapped(target, item) {\n  if (isReadonly(target)) {\n    return isReactive(target) ? toReadonly(toReactive(item)) : toReadonly(item);\n  }\n  return toReactive(item);\n}\nconst arrayInstrumentations = {\n  __proto__: null,\n  [Symbol.iterator]() {\n    return iterator(this, Symbol.iterator, (item) => toWrapped(this, item));\n  },\n  concat(...args) {\n    return reactiveReadArray(this).concat(\n      ...args.map((x) => isArray(x) ? reactiveReadArray(x) : x)\n    );\n  },\n  entries() {\n    return iterator(this, \"entries\", (value) => {\n      value[1] = toWrapped(this, value[1]);\n      return value;\n    });\n  },\n  every(fn, thisArg) {\n    return apply(this, \"every\", fn, thisArg, void 0, arguments);\n  },\n  filter(fn, thisArg) {\n    return apply(\n      this,\n      \"filter\",\n      fn,\n      thisArg,\n      (v) => v.map((item) => toWrapped(this, item)),\n      arguments\n    );\n  },\n  find(fn, thisArg) {\n    return apply(\n      this,\n      \"find\",\n      fn,\n      thisArg,\n      (item) => toWrapped(this, item),\n      arguments\n    );\n  },\n  findIndex(fn, thisArg) {\n    return apply(this, \"findIndex\", fn, thisArg, void 0, arguments);\n  },\n  findLast(fn, thisArg) {\n    return apply(\n      this,\n      \"findLast\",\n      fn,\n      thisArg,\n      (item) => toWrapped(this, item),\n      arguments\n    );\n  },\n  findLastIndex(fn, thisArg) {\n    return apply(this, \"findLastIndex\", fn, thisArg, void 0, arguments);\n  },\n  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement\n  forEach(fn, thisArg) {\n    return apply(this, \"forEach\", fn, thisArg, void 0, arguments);\n  },\n  includes(...args) {\n    return searchProxy(this, \"includes\", args);\n  },\n  indexOf(...args) {\n    return searchProxy(this, \"indexOf\", args);\n  },\n  join(separator) {\n    return reactiveReadArray(this).join(separator);\n  },\n  // keys() iterator only reads `length`, no optimization required\n  lastIndexOf(...args) {\n    return searchProxy(this, \"lastIndexOf\", args);\n  },\n  map(fn, thisArg) {\n    return apply(this, \"map\", fn, thisArg, void 0, arguments);\n  },\n  pop() {\n    return noTracking(this, \"pop\");\n  },\n  push(...args) {\n    return noTracking(this, \"push\", args);\n  },\n  reduce(fn, ...args) {\n    return reduce(this, \"reduce\", fn, args);\n  },\n  reduceRight(fn, ...args) {\n    return reduce(this, \"reduceRight\", fn, args);\n  },\n  shift() {\n    return noTracking(this, \"shift\");\n  },\n  // slice could use ARRAY_ITERATE but also seems to beg for range tracking\n  some(fn, thisArg) {\n    return apply(this, \"some\", fn, thisArg, void 0, arguments);\n  },\n  splice(...args) {\n    return noTracking(this, \"splice\", args);\n  },\n  toReversed() {\n    return reactiveReadArray(this).toReversed();\n  },\n  toSorted(comparer) {\n    return reactiveReadArray(this).toSorted(comparer);\n  },\n  toSpliced(...args) {\n    return reactiveReadArray(this).toSpliced(...args);\n  },\n  unshift(...args) {\n    return noTracking(this, \"unshift\", args);\n  },\n  values() {\n    return iterator(this, \"values\", (item) => toWrapped(this, item));\n  }\n};\nfunction iterator(self, method, wrapValue) {\n  const arr = shallowReadArray(self);\n  const iter = arr[method]();\n  if (arr !== self && !isShallow(self)) {\n    iter._next = iter.next;\n    iter.next = () => {\n      const result = iter._next();\n      if (!result.done) {\n        result.value = wrapValue(result.value);\n      }\n      return result;\n    };\n  }\n  return iter;\n}\nconst arrayProto = Array.prototype;\nfunction apply(self, method, fn, thisArg, wrappedRetFn, args) {\n  const arr = shallowReadArray(self);\n  const needsWrap = arr !== self && !isShallow(self);\n  const methodFn = arr[method];\n  if (methodFn !== arrayProto[method]) {\n    const result2 = methodFn.apply(self, args);\n    return needsWrap ? toReactive(result2) : result2;\n  }\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (needsWrap) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, toWrapped(self, item), index, self);\n      };\n    } else if (fn.length > 2) {\n      wrappedFn = function(item, index) {\n        return fn.call(this, item, index, self);\n      };\n    }\n  }\n  const result = methodFn.call(arr, wrappedFn, thisArg);\n  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;\n}\nfunction reduce(self, method, fn, args) {\n  const arr = shallowReadArray(self);\n  let wrappedFn = fn;\n  if (arr !== self) {\n    if (!isShallow(self)) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, toWrapped(self, item), index, self);\n      };\n    } else if (fn.length > 3) {\n      wrappedFn = function(acc, item, index) {\n        return fn.call(this, acc, item, index, self);\n      };\n    }\n  }\n  return arr[method](wrappedFn, ...args);\n}\nfunction searchProxy(self, method, args) {\n  const arr = toRaw(self);\n  track(arr, \"iterate\", ARRAY_ITERATE_KEY);\n  const res = arr[method](...args);\n  if ((res === -1 || res === false) && isProxy(args[0])) {\n    args[0] = toRaw(args[0]);\n    return arr[method](...args);\n  }\n  return res;\n}\nfunction noTracking(self, method, args = []) {\n  pauseTracking();\n  startBatch();\n  const res = toRaw(self)[method].apply(self, args);\n  endBatch();\n  resetTracking();\n  return res;\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key)) key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  get(target, key, receiver) {\n    if (key === \"__v_skip\") return target[\"__v_skip\"];\n    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the receiver is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      let fn;\n      if (targetIsArray && (fn = arrayInstrumentations[key])) {\n        return fn;\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(\n      target,\n      key,\n      // if this is a proxy wrapping a ref, return methods using the raw ref\n      // as receiver so that we don't have to call `toRaw` on the ref in all\n      // its class methods\n      isRef(target) ? target : receiver\n    );\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (isShallow2) {\n      return res;\n    }\n    if (isRef(res)) {\n      const value = targetIsArray && isIntegerKey(key) ? res : res.value;\n      return isReadonly2 && isObject(value) ? readonly(value) : value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    const isArrayWithIntegerKey = isArray(target) && isIntegerKey(key);\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArrayWithIntegerKey && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            warn(\n              `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n              target[key]\n            );\n          }\n          return true;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = isArrayWithIntegerKey ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(\n      target,\n      key,\n      value,\n      isRef(target) ? target : receiver\n    );\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      isArray(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction createIterableMethod(method, isReadonly2, isShallow2) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;\n    !isReadonly2 && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations(readonly, shallow) {\n  const instrumentations = {\n    get(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"get\", key);\n        }\n        track(rawTarget, \"get\", rawKey);\n      }\n      const { has } = getProto(rawTarget);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n      } else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n      } else if (target !== rawTarget) {\n        target.get(key);\n      }\n    },\n    get size() {\n      const target = this[\"__v_raw\"];\n      !readonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n      return target.size;\n    },\n    has(key) {\n      const target = this[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const rawKey = toRaw(key);\n      if (!readonly) {\n        if (hasChanged(key, rawKey)) {\n          track(rawTarget, \"has\", key);\n        }\n        track(rawTarget, \"has\", rawKey);\n      }\n      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n    },\n    forEach(callback, thisArg) {\n      const observed = this;\n      const target = observed[\"__v_raw\"];\n      const rawTarget = toRaw(target);\n      const wrap = shallow ? toShallow : readonly ? toReadonly : toReactive;\n      !readonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n      return target.forEach((value, key) => {\n        return callback.call(thisArg, wrap(value), wrap(key), observed);\n      });\n    }\n  };\n  extend(\n    instrumentations,\n    readonly ? {\n      add: createReadonlyMethod(\"add\"),\n      set: createReadonlyMethod(\"set\"),\n      delete: createReadonlyMethod(\"delete\"),\n      clear: createReadonlyMethod(\"clear\")\n    } : {\n      add(value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const proto = getProto(target);\n        const hadKey = proto.has.call(target, value);\n        if (!hadKey) {\n          target.add(value);\n          trigger(target, \"add\", value, value);\n        }\n        return this;\n      },\n      set(key, value) {\n        if (!shallow && !isShallow(value) && !isReadonly(value)) {\n          value = toRaw(value);\n        }\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get.call(target, key);\n        target.set(key, value);\n        if (!hadKey) {\n          trigger(target, \"add\", key, value);\n        } else if (hasChanged(value, oldValue)) {\n          trigger(target, \"set\", key, value, oldValue);\n        }\n        return this;\n      },\n      delete(key) {\n        const target = toRaw(this);\n        const { has, get } = getProto(target);\n        let hadKey = has.call(target, key);\n        if (!hadKey) {\n          key = toRaw(key);\n          hadKey = has.call(target, key);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkIdentityKeys(target, has, key);\n        }\n        const oldValue = get ? get.call(target, key) : void 0;\n        const result = target.delete(key);\n        if (hadKey) {\n          trigger(target, \"delete\", key, void 0, oldValue);\n        }\n        return result;\n      },\n      clear() {\n        const target = toRaw(this);\n        const hadItems = target.size !== 0;\n        const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n        const result = target.clear();\n        if (hadItems) {\n          trigger(\n            target,\n            \"clear\",\n            void 0,\n            void 0,\n            oldTarget\n          );\n        }\n        return result;\n      }\n    }\n  );\n  const iteratorMethods = [\n    \"keys\",\n    \"values\",\n    \"entries\",\n    Symbol.iterator\n  ];\n  iteratorMethods.forEach((method) => {\n    instrumentations[method] = createIterableMethod(method, readonly, shallow);\n  });\n  return instrumentations;\n}\nfunction createInstrumentationGetter(isReadonly2, shallow) {\n  const instrumentations = createInstrumentations(isReadonly2, shallow);\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `value cannot be made ${isReadonly2 ? \"readonly\" : \"reactive\"}: ${String(\n          target\n        )}`\n      );\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (!hasOwn(value, \"__v_skip\") && Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction isRef(r) {\n  return r ? r[\"__v_isRef\"] === true : false;\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, isShallow2) {\n    this.dep = new Dep();\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isShallow\"] = false;\n    this._rawValue = isShallow2 ? value : toRaw(value);\n    this._value = isShallow2 ? value : toReactive(value);\n    this[\"__v_isShallow\"] = isShallow2;\n  }\n  get value() {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      this.dep.track({\n        target: this,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      this.dep.track();\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    const oldValue = this._rawValue;\n    const useDirectValue = this[\"__v_isShallow\"] || isShallow(newValue) || isReadonly(newValue);\n    newValue = useDirectValue ? newValue : toRaw(newValue);\n    if (hasChanged(newValue, oldValue)) {\n      this._rawValue = newValue;\n      this._value = useDirectValue ? newValue : toReactive(newValue);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        this.dep.trigger({\n          target: this,\n          type: \"set\",\n          key: \"value\",\n          newValue,\n          oldValue\n        });\n      } else {\n        this.dep.trigger();\n      }\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  if (ref2.dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      ref2.dep.trigger({\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: ref2._value\n      });\n    } else {\n      ref2.dep.trigger();\n    }\n  }\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => key === \"__v_raw\" ? target : unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    const dep = this.dep = new Dep();\n    const { get, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._value = this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this[\"__v_isRef\"] = true;\n    this._value = void 0;\n    this._raw = toRaw(_object);\n    let shallow = true;\n    let obj = _object;\n    if (!isArray(_object) || !isIntegerKey(String(_key))) {\n      do {\n        shallow = !isProxy(obj) || isShallow(obj);\n      } while (shallow && (obj = obj[\"__v_raw\"]));\n    }\n    this._shallow = shallow;\n  }\n  get value() {\n    let val = this._object[this._key];\n    if (this._shallow) {\n      val = unref(val);\n    }\n    return this._value = val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    if (this._shallow && isRef(this._raw[this._key])) {\n      const nestedRef = this._object[this._key];\n      if (isRef(nestedRef)) {\n        nestedRef.value = newVal;\n        return;\n      }\n    }\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(this._raw, this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this[\"__v_isRef\"] = true;\n    this[\"__v_isReadonly\"] = true;\n    this._value = void 0;\n  }\n  get value() {\n    return this._value = this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  return new ObjectRefImpl(source, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(fn, setter, isSSR) {\n    this.fn = fn;\n    this.setter = setter;\n    /**\n     * @internal\n     */\n    this._value = void 0;\n    /**\n     * @internal\n     */\n    this.dep = new Dep(this);\n    /**\n     * @internal\n     */\n    this.__v_isRef = true;\n    // TODO isolatedDeclarations \"__v_isReadonly\"\n    // A computed is also a subscriber that tracks other deps\n    /**\n     * @internal\n     */\n    this.deps = void 0;\n    /**\n     * @internal\n     */\n    this.depsTail = void 0;\n    /**\n     * @internal\n     */\n    this.flags = 16;\n    /**\n     * @internal\n     */\n    this.globalVersion = globalVersion - 1;\n    /**\n     * @internal\n     */\n    this.next = void 0;\n    // for backwards compat\n    this.effect = this;\n    this[\"__v_isReadonly\"] = !setter;\n    this.isSSR = isSSR;\n  }\n  /**\n   * @internal\n   */\n  notify() {\n    this.flags |= 16;\n    if (!(this.flags & 8) && // avoid infinite self recursion\n    activeSub !== this) {\n      batch(this, true);\n      return true;\n    } else if (!!(process.env.NODE_ENV !== \"production\")) ;\n  }\n  get value() {\n    const link = !!(process.env.NODE_ENV !== \"production\") ? this.dep.track({\n      target: this,\n      type: \"get\",\n      key: \"value\"\n    }) : this.dep.track();\n    refreshComputed(this);\n    if (link) {\n      link.version = this.dep.version;\n    }\n    return this._value;\n  }\n  set value(newValue) {\n    if (this.setter) {\n      this.setter(newValue);\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\"Write operation failed: computed value is readonly\");\n    }\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.onTrack = debugOptions.onTrack;\n    cRef.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\",\n  \"IS_REF\": \"__v_isRef\"\n};\n\nconst WatchErrorCodes = {\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\"\n};\nconst INITIAL_WATCHER_VALUE = {};\nconst cleanupMap = /* @__PURE__ */ new WeakMap();\nlet activeWatcher = void 0;\nfunction getCurrentWatcher() {\n  return activeWatcher;\n}\nfunction onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {\n  if (owner) {\n    let cleanups = cleanupMap.get(owner);\n    if (!cleanups) cleanupMap.set(owner, cleanups = []);\n    cleanups.push(cleanupFn);\n  } else if (!!(process.env.NODE_ENV !== \"production\") && !failSilently) {\n    warn(\n      `onWatcherCleanup() was called when there was no active watcher to associate with.`\n    );\n  }\n}\nfunction watch(source, cb, options = EMPTY_OBJ) {\n  const { immediate, deep, once, scheduler, augmentJob, call } = options;\n  const warnInvalidSource = (s) => {\n    (options.onWarn || warn)(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`\n    );\n  };\n  const reactiveGetter = (source2) => {\n    if (deep) return source2;\n    if (isShallow(source2) || deep === false || deep === 0)\n      return traverse(source2, 1);\n    return traverse(source2);\n  };\n  let effect;\n  let getter;\n  let cleanup;\n  let boundCleanup;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));\n    getter = () => source.map((s) => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if (isFunction(s)) {\n        return call ? call(s, 2) : s();\n      } else {\n        !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      getter = call ? () => call(source, 2) : source;\n    } else {\n      getter = () => {\n        if (cleanup) {\n          pauseTracking();\n          try {\n            cleanup();\n          } finally {\n            resetTracking();\n          }\n        }\n        const currentEffect = activeWatcher;\n        activeWatcher = effect;\n        try {\n          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);\n        } finally {\n          activeWatcher = currentEffect;\n        }\n      };\n    }\n  } else {\n    getter = NOOP;\n    !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    const depth = deep === true ? Infinity : deep;\n    getter = () => traverse(baseGetter(), depth);\n  }\n  const scope = getCurrentScope();\n  const watchHandle = () => {\n    effect.stop();\n    if (scope && scope.active) {\n      remove(scope.effects, effect);\n    }\n  };\n  if (once && cb) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      watchHandle();\n    };\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = (immediateFirstRun) => {\n    if (!(effect.flags & 1) || !effect.dirty && !immediateFirstRun) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue))) {\n        if (cleanup) {\n          cleanup();\n        }\n        const currentWatcher = activeWatcher;\n        activeWatcher = effect;\n        try {\n          const args = [\n            newValue,\n            // pass undefined as the old value when it's changed for the first time\n            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,\n            boundCleanup\n          ];\n          oldValue = newValue;\n          call ? call(cb, 3, args) : (\n            // @ts-expect-error\n            cb(...args)\n          );\n        } finally {\n          activeWatcher = currentWatcher;\n        }\n      }\n    } else {\n      effect.run();\n    }\n  };\n  if (augmentJob) {\n    augmentJob(job);\n  }\n  effect = new ReactiveEffect(getter);\n  effect.scheduler = scheduler ? () => scheduler(job, false) : job;\n  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect);\n  cleanup = effect.onStop = () => {\n    const cleanups = cleanupMap.get(effect);\n    if (cleanups) {\n      if (call) {\n        call(cleanups, 4);\n      } else {\n        for (const cleanup2 of cleanups) cleanup2();\n      }\n      cleanupMap.delete(effect);\n    }\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    effect.onTrack = options.onTrack;\n    effect.onTrigger = options.onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job(true);\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (scheduler) {\n    scheduler(job.bind(null, true), true);\n  } else {\n    effect.run();\n  }\n  watchHandle.pause = effect.pause.bind(effect);\n  watchHandle.resume = effect.resume.bind(effect);\n  watchHandle.stop = watchHandle;\n  return watchHandle;\n}\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */ new Map();\n  if ((seen.get(value) || 0) >= depth) {\n    return value;\n  }\n  seen.set(value, depth);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach((v) => {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n    for (const key of Object.getOwnPropertySymbols(value)) {\n      if (Object.prototype.propertyIsEnumerable.call(value, key)) {\n        traverse(value[key], depth, seen);\n      }\n    }\n  }\n  return value;\n}\n\nexport { ARRAY_ITERATE_KEY, EffectFlags, EffectScope, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, WatchErrorCodes, computed, customRef, effect, effectScope, enableTracking, getCurrentScope, getCurrentWatcher, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onEffectCleanup, onScopeDispose, onWatcherCleanup, pauseTracking, proxyRefs, reactive, reactiveReadArray, readonly, ref, resetTracking, shallowReactive, shallowReadArray, shallowReadonly, shallowRef, stop, toRaw, toReactive, toReadonly, toRef, toRefs, toValue, track, traverse, trigger, triggerRef, unref, watch };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}